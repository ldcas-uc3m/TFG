\chapter{Analysis}\label{chap:analysis}
This chapter describes the proposed solution by briefly recapping the project (\sectionref{project-description}), specifying the system's requirements (\sectionref{requirements}), and specifying the possible use cases of the system (\sectionref{use-cases}). Finally, we verify our specifications through the use of traceability matrices (\sectionref{req-traceability}).



\section{Project overview}\label{sec:project-description}
% peque√±o resumen del projecto
The main objective of this project is to create an application that is capable of simulating an \gls{ISA} defined by the user, with educational purposes. This will help the user learn \gls{assembly} programming by incentivizing experimentation and, in turn, giving the user a deeper understanding of \gls{assembly} programming. Moreover, the instructions should be defined using a simple language that supports some form of validation of the instruction set, in order to facilitate ensuring that the \gls{ISA} is correct even before executing any program.

As stated in \chapterref{state-of-the-art}, current simulators either don't offer this possibility, or offer an overwhelming amount of options and configurations, which focus on the hardware and architecture aspects of the simulation instead on the \gls{assembly} itself.

Our aim is to provide the user with a more \textit{logical} approach to understanding \gls{assembly} programming, by abstracting the hardware details and providing a simple and generic architecture.



\section{Requirements}\label{sec:requirements}
This section provides a detailed description of the system's requirements. For the requirement specification task, the IEEE recommended practices \parencite{IEEE830-1984} were followed. According to these practices, a good specification must address the software functionality, performance issues, external interfaces, other non-functional features and design or implementation constraints.

Moreover, the requirement specification must be:
\begin{enumerate}
  \item \textbf{Complete:} the document reflects all significant software requirements.
  \item \textbf{Consistent:} requirements must not generate conflicts with each other.
  \item \textbf{Correct:} every requirement is one that the software shall meet according to the user needs.
  \item \textbf{Modifiable:} the structure of the specification allows changes to the requirements in a simple, complete and consistent way.
  \item \textbf{Ranked based on importance and stability:} every requirement must indicate its importance and its stability.
  \item \textbf{Traceable:} the origin of every requirement is clear, and it can be easily referenced in further stages.
  \item \textbf{Unambiguous:} every requirement has a single interpretation.
  \item \textbf{Verifiable:} every requirement must be verifiable, that is, there exists some process to verify that the software complies with every single requirement.
\end{enumerate}

Starting from the user requirements (\subsectionref{user-requirements}), which constitute an informal reference to the product the client expects, we derived the software requirements (\subsectionref{soft-requirements}) that guided the design process with specific information on the functionality of the system, as well as any and other related characteristics.



\subsection{User requirements}\label{subsec:user-requirements}
This section provides a detailed description of the user's requirements for the project. These requirements indicate the main functionality and restrictions the developed system must fulfill.

The user requirements are divided into two distinct types:
\begin{itemize}
  \item \textbf{Capacities:} Describe the expected system's functionality.
  \item \textbf{Restrictions:} Impose constraints or conditions that the system must fulfill.
\end{itemize}

Each user requirement is uniquely identified by an ID, which follows the format \textit{UR-YY-XX}, where \textit{YY} identifies the type of the requirement, either a capacity (\textit{CA}) or a restriction (\textit{RE}); and \textit{XX} identifies the sequential number of the requirement within that type, starting at \textit{01}. Table \ref{tab:ur-template} provides the template used for the specification of the requirements, including the description of each attribute.

\printureqtemplate{UR-YY-XX}


\newcounter{i}

% capacities
\setcounter{i}{1}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=m}
  The system shall simulate a basic and generic computer architecture.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  The system shall display information about all system components at each step of the simulation.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  The system shall allow the user to define its own \gls{ISA} using a simple and validatable language.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=m}
  The system shall be able to execute any program written in the defined instruction set, instruction by instruction.
\end{userReq}
\stepcounter{i}



% restrictions
\setcounter{i}{1}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=h,s=nc,v=h}
  The system shall be able to be executed natively, and support multiple platforms.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=m,s=nc,v=h}
  The system's source code shall be publicly available.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=m,s=nc,v=l}
  The system shall be intuitive and easy to use.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=l,pd=l,s=nc,v=h}
  The system shall have a \gls{CLI}.
\end{userReq}
\stepcounter{i}


\FloatBarrier  % prevent floats from passing this point


\subsection{Software requirements}\label{subsec:soft-requirements}
This section provides a detailed description of the system's software requirements for the project. These requirements are derived from the user requirements, defined in Subsection \ref{subsec:user-requirements}, and comprise the software specifications for the system.

The user requirements are divided into two distinct types:
\begin{itemize}
  \item \textbf{Functional requirements:} Specify the software's functionalities and characteristics.
  \item \textbf{Non-functional requirements:} Specify other non-functional characteristics of the software.
\end{itemize}

Each user requirement is uniquely identified by an ID, which follows the format \textit{SR-YY-XX}, where \textit{YY} identifies the type of the requirement, either functional (\textit{FC}) or non-functional (\textit{NF}); and \textit{XX} identifies the sequential number of the requirement within that type, starting at \textit{01}. Table \ref{tab:sr-template} provides the template used for the specification of the requirements, including the description of each attribute.

\printsreqtemplate{SR-YY-XX}


% functional
\setcounter{i}{1}


% non-functional
\setcounter{i}{1}


\FloatBarrier

\section{Use cases}\label{sec:use-cases}

\printuctemplate{UC-XX}


\FloatBarrier



\section{Traceability}\label{sec:req-traceability}