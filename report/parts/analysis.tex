\chapter{Analysis}\label{chap:analysis}
This chapter describes the proposed solution by briefly recapping the project (\secref{project-description}), specifying the system's requirements (\secref{requirements}), and specifying the different use cases for the system (\secref{use-cases}).



\section{Project Overview}\label{sec:project-description}
% peque√±o resumen del projecto
The main objective of this project is to create an application that is capable of simulating an \gls{ISA} defined by the user, with educational purposes. This will help the user learn \gls{assembly} programming by incentivizing experimentation and, in turn, giving the user a deeper understanding of \gls{assembly} programming. Moreover, the instructions should be defined using a simple language that supports some form of validation of the instruction set, in order to facilitate ensuring that the \gls{ISA} is correct even before executing any program.

As stated in \chapref{state-of-the-art}, current simulators either don't offer this possibility, or offer an overwhelming amount of options and configurations, which focus on the hardware and architecture aspects of the simulation instead on the \gls{assembly} itself.

The aim is to provide the user with a more \textit{logical} approach to understanding \gls{assembly} programming, by abstracting the hardware details and providing a simple and generic architecture.



\section{Requirements}\label{sec:requirements}
This section provides a detailed description of the system's requirements. For the requirement specification task, the IEEE recommended practices \parencite{IEEE830-1984} were followed. According to these practices, a good specification must address the software functionality, performance issues, external interfaces, other non-functional features and design or implementation constraints.

Moreover, the requirement specification must be:
\begin{enumerate}
  \item \textbf{Complete:} the document reflects all significant software requirements.
  \item \textbf{Consistent:} requirements must not generate conflicts with each other.
  \item \textbf{Correct:} every requirement is one that the software shall meet according to the user needs.
  \item \textbf{Modifiable:} the structure of the specification allows changes to the requirements in a simple, complete and consistent way.
  \item \textbf{Ranked based on importance and stability:} every requirement must indicate its importance and its stability.
  \item \textbf{Traceable:} the origin of every requirement is clear, and it can be easily referenced in further stages.
  \item \textbf{Unambiguous:} every requirement has a single interpretation.
  \item \textbf{Verifiable:} every requirement must be verifiable, that is, there exists some process to verify that the software complies with every single requirement.
\end{enumerate}

Starting from the user requirements (\subsecref{user-requirements}), which constitute an informal reference to the product the client expects, the software requirements (\subsecref{soft-requirements}) were derived. These requirements guided the design process with specific information on the functionality of the system, as well as any and other related characteristics.



\subsection{User Requirements}\label{subsec:user-requirements}
This section provides a detailed description of the user's requirements for the project. These requirements indicate the main functionality and restrictions the developed system must fulfill.

The user requirements are divided into two distinct types:
\begin{itemize}
  \item \textbf{Capacities:} Describe the expected system's functionality.
  \item \textbf{Restrictions:} Impose constraints or conditions that the system must fulfill.
\end{itemize}

Each user requirement is uniquely identified by an ID, which follows the format \textit{UR-YY-XX}, where \textit{YY} identifies the type of the requirement, either a capacity (\textit{CA}) or a restriction (\textit{RE}); and \textit{XX} identifies the sequential number of the requirement within that type, starting at \textit{01}.

\tabref{ur-template} provides the template used for the specification of the requirements, including the description of each attribute.

\printureqtemplate{UR-YY-XX}


\newcounter{i}

% capacities
\setcounter{i}{1}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=m}
  The system shall simulate a basic and generic computer architecture.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  The system shall display information about all system components at each step of the simulation.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  The system shall allow the user to define its own \gls{ISA}.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=m}
  The system shall be able to execute any program written in the defined instruction set, instruction by instruction.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=m,pd=m,s=c,v=h}
  The system shall have a \gls{CLI}.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  The system shall notify the user of syntax errors in the program.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=l,pd=l,s=nc,v=h}
  The data on the components shall be represented in various formats: signed integer, unsigned integer, and hexadecimal.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=m,pd=m,s=nc,v=h}
  The system shall be able to fully execute and stop the execution of any program.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-CA-\padtwo{i}}{pc=m,pd=m,s=nc,v=h}
  The system shall provide a \gls{REPL environment} for the user to test the instruction definition language.
\end{userReq}
\stepcounter{i}


% restrictions
\setcounter{i}{1}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=h,s=c,v=m}
  The system shall be able to be executed natively, and support multiple platforms.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=m,s=nc,v=h}
  The system shall be \gls{FOSS}.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=m,s=nc,v=l}
  The system shall be intuitive and easy to use.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=h,pd=m,s=nc,v=h}
  The system shall provide a comprehensive user manual.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=m,s=nc,v=m}
  The \gls{ISA} definition format shall be simple and easily modifiable.
\end{userReq}
\stepcounter{i}

\begin{userReq}{UR-RE-\padtwo{i}}{pc=m,pd=m,s=nc,v=l}
  The instruction definition language shall be simple, easy to understand, and  validatable by an external tool.
\end{userReq}
\stepcounter{i}


\FloatBarrier  % prevent floats from passing this point


\subsection{Software Requirements}\label{subsec:soft-requirements}
This section provides a detailed description of the system's software requirements for the project. These requirements are derived from the user requirements, defined in Subsection \ref{subsec:user-requirements}, and comprise the software specifications for the system.

The user requirements are divided into two distinct types:
\begin{itemize}
  \item \textbf{Functional requirements:} Specify the software's functionalities and characteristics.
  \item \textbf{Non-functional requirements:} Specify other non-functional characteristics of the software.
\end{itemize}

Each user requirement is uniquely identified by an ID, which follows the format \textit{SR-YY-XX}, where \textit{YY} identifies the type of the requirement, either functional (\textit{FC}) or non-functional (\textit{NF}); and \textit{XX} identifies the sequential number of the requirement within that type, starting at \textit{01}.

\tabref{sr-template} provides the template used for the specification of the requirements, including the description of each attribute.

\printsreqtemplate{SR-YY-XX}


% functional
\setcounter{i}{1}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-01}
  The system shall simulate the basic components of a computer: \gls{data memory}, \gls{text memory}, \glspl{register}, \gls{ALU} and \gls{I/O}.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=c,v=m}
  {UR-CA-01, UR-CA-03}
  The system shall simulate all basic computer operations: \glspl{arithmetic operation}, \glspl{logical operation}, \glsdisp{branch}{branching}, \gls{memory} manipulation, and \gls{I/O}.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-02}
  The system shall display the contents and state of the components of the current \gls{ISA} at each step of the simulation.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-01, UR-CA-03}
  The user shall be able to configure the different components of the simulator.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-03}
  The system shall be able to interpret instructions defined in a simple language.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-04}
  The system shall be able to transform \glsdisp{assembly}{assembly}-like instructions, defined in the \gls{ISA}, into instructions in a simple language that the system can interpret.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-04}
  The system shall be able to execute programs instruction by instruction.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-04}
  The user shall be able to load programs and \gls{ISA} definitions in the simulator.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-05}
  The user shall be able to interact with the system through a \gls{CLI}.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-06}
  The system shall detect syntactical errors on the executed program.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=h,pd=h,s=nc,v=h}
  {UR-CA-07}
  The user shall be able to change the representation of the data on the components: either signed integer, unsigned integer, or hexadecimal.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=m,pd=m,s=c,v=h}
  {UR-CA-08}
  The user shall allow the user to start executing the rest of the program automatically, and stop the execution of a current program.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-FC-\padtwo{i}}{pc=m,pd=m,s=c,v=h}
  {UR-CA-09}
  The system shall provide a \gls{REPL environment} for the instruction definition language.
\end{softwareReq}
\stepcounter{i}


% non-functional
\setcounter{i}{1}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=h,s=nc,v=h}
  {UR-RE-01}
  The system shall be able to be executed natively.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=h,s=nc,v=h}
  {UR-RE-01}
  The system shall support multiple platforms.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=m,s=nc,v=h}
  {UR-RE-02}
  The system shall be licensed under a \gls{FOSS} license.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=l,pd=l,s=nc,v=h}
  {UR-RE-02}
  The system's source code shall be publicly available.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=m,s=nc,v=l}
  {UR-RE-03}
  The system shall have an intuitive \gls{UI}.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=m,s=nc,v=l}
  {UR-RE-04}
  The system shall provide a comprehensive user manual.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=l,s=c,v=m}
  {UR-RE-05}
  The format used to define the \gls{ISA} shall be simple and easily modifiable.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=l,s=c,v=m}
  {UR-RE-06}
  The language used to define the instructions shall be easily validatable by and external tool.
\end{softwareReq}
\stepcounter{i}

\begin{softwareReq}{SR-NF-\padtwo{i}}{pc=m,pd=m,s=c,v=l}
  {UR-RE-06}
  The language used to shall be simple and easy for the user to use and understand.
\end{softwareReq}
\stepcounter{i}

\FloatBarrier


\subsection{Traceability}\label{subsec:req-traceability}
A traceability matrix verifies if software requirements cover all user requirements. All functional requirements cover the capabilities (\tabref{traceability-ca-fc}) and all non-functional requirements cover the restrictions (\tabref{traceability-re-nf}), proving the analysis was correct.

% SR-FC - UR-CA
\traceabilityTable{traceability-ca-fc}
  {^SR\37-FC}{^UR\37-CA}
  {Traceability between capacities and functional requirements}

% SR-NF - UR-RE
\traceabilityTable{traceability-re-nf}
  {^SR\37-NF}{^UR\37-RE}
  {Traceability between restrictions and non-functional requirements}

% Note that `-` is a special character in Lua patterns and should be escaped, using \37

\FloatBarrier


\section{Use Cases}\label{sec:use-cases}
The UML use case model \parencite{Cook2017} (\figref{use_case_model}) represents the typical usage of the system, allowing developer to visualize the different interactions between the user and the functionalities the system offers. The use case model includes all the different use cases for the system.

\drawiosvgfigure[.8]{use_case_model}{Use case model}

Each use case represents the process an external agent (actor) should follow in order to execute a specific functionality, and is uniquely identified by an ID. The ID follows the format \textit{UC-XX}, where \textit{XX} identifies the sequential number of the use case, starting at \textit{01}.

\tabref{uc-template} provides the template used for the specification of the use case, including the description of each attribute.

\printuctemplate{UC-XX}


\setcounter{i}{1}

\begin{useCase}{UC-\padtwo{i}}
  {Load \gls{ISA}}  % name
  {User}  % actors
  {Loading the \gls{ISA} on the simulator from a file specified by the user.}  % objetive
  {None.}  % pre-cond
  {The \gls{ISA} is loaded in the simulator, and the main \gls{CLI} starts.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User provides the route to the \gls{ISA} file through an executable argument.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

\begin{useCase}{UC-\padtwo{i}}
  {Load program}  % name
  {User}  % actors
  {Loading a program on the simulator from a file specified by the user.}  % objetive
  {The \gls{ISA} is loaded in the simulator.}  % pre-cond
  {The program is loaded in the simulator.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User selects the `load program' option in the \gls{CLI}.
    \item User specifies the route to the program file.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

\begin{useCase}{UC-\padtwo{i}}
  {Execute instruction}  % name
  {User}  % actors
  {Executing the next instruction of the program on the simulator.}  % objetive
  {The \gls{ISA} and program are loaded in the simulator.}  % pre-cond
  {The simulator executes one instruction of the program.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User selects the `next instruction' option in the \gls{CLI}.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

\begin{useCase}{UC-\padtwo{i}}
  {Full program execution}  % name
  {User}  % actors
  {Fully executing the current program.}  % objetive
  {The \gls{ISA} and program are loaded in the simulator.}  % pre-cond
  {The simulator starts/continues executing the program automatically.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User selects the `full execution' option in the \gls{CLI}.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

\begin{useCase}{UC-\padtwo{i}}
  {Stop program execution}  % name
  {User}  % actors
  {Stopping the current program execution.}  % objetive
  {The \gls{ISA} and program are loaded in the simulator, and the program is executing.}  % pre-cond
  {The simulator stops executing the program.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User selects the `stop execution' option in the \gls{CLI}.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

\begin{useCase}{UC-\padtwo{i}}
  {Execute instruction}  % name
  {User}  % actors
  {Executing the next instruction of the program on the simulator.}  % objetive
  {The \gls{ISA} and program are loaded in the simulator.}  % pre-cond
  {The simulator executes one instruction of the program.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User selects the `next instruction' option in the \gls{CLI}.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

\begin{useCase}{UC-\padtwo{i}}
  {Use \gls{REPL environment}}  % name
  {User}  % actors
  {Evaluating instruction definition Language expressions.}  % objetive
  {The \gls{ISA} and program are loaded in the simulator.}  % pre-cond
  {The simulator evaluates the expressions.}  % post-cond
  \begin{enumerate}[leftmargin=*, topsep=0pt, noitemsep]  % description
    \item User selects the `REPL' option in the \gls{CLI}.
    \item User types the expression to evaluate.
  \end{enumerate}
\end{useCase}
\stepcounter{i}

