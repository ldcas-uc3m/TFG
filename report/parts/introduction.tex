\chapter{Introduction}\label{chap:introduction}
This first chapter briefly presents the project: why it came to be (\sectionref{sec:motivation}), the objectives it strives to fulfill (\sectionref{sec:objectives}), and a description of the overall document structure (\sectionref{sec:structure}).


\section{Motivation}\label{sec:motivation}
% why assembly?
\Gls{programming} is the process of expressing abstract ideas and models within a language. These languages can be either \glspl{high-level language}, with more abstractions, or \glspl{low-level language}, with few abstractions; but for any language to work for a specific \gls{processor}, that \gls{processor} must be able to interpret and execute it. \Glspl{low-level language} are built on a set of instructions, each one executing a single `atomic' function on several (or none) defined data, providing the `benefit' of having no context, which simplifies the electronics. This also makes them more flexible and robust, which is why \glspl{high-level language} are built upon these \glspl{low-level language}, by being \glsdisp{compilation}{compiled} (translated) from high-level to low-level.

Specifically, we call  the languages that processors interpret `\glspl{assembly}'. In order to get the maximum performance from a \gls{processor}, using them effectively is essential, as they give the \gls{programmer} the maximum control over the hardware. Due to the fact that, as stated before, \glspl{high-level language} are built on top of \glspl{assembly}, understanding the latter is also necessary for not only creating the former, but also for effectively utilizing them, as different abstractions might affect what the \gls{processor} will actually do.

For all these reasons, amongst others \supercite{jorgensen2019x86}, learning how \glspl{assembly} work is required for any \gls{computer science} student, or any \gls{software engineer}, given that it offers a better understanding of the underlying architecture, therefore enabling them to more efficiently use that architecture, but also enabling them to better express those abstract ideas in terms that the \gls{processor} will understand.


% why generic/LISP?
Moreover, it is not worth learning one specific \gls{assembly} for one specific architecture, not only because architectures change with time and the principles and concepts behind those specific languages don't, but because understanding those principles allows a person to abstract from the specific details of the implementation, transferring knowledge `horizontaly' to another \glspl{assembly} and `vertically' to the \glspl{high-level language}. As a professor from the University of Iowa put it almost forty years ago, \textcquote{DeckerWilliamF.1985Amat}{[a] student who learns to compare and contrast machines based on a generic model and who understands the relationship of higher level ideas to the generic machine will be better prepared to function for a longer period of time}.


% why a simulator?
Unfortunately, the act of learning \glspl{assembly} has been proven difficult, as the low-level abstractions make it difficult for the abstract human brain to adapt to. There have been several approaches used in order to enhance the learning, such as self-explaining and the use of architecture diagrams \supercite{HungY.-C2012CSWC}, but I propose the `simulator' approach: allowing the user to execute instructions step by step and to see state of the different subcomponents of the virtual \gls{computer} `in real time'. This, added to the more `generic' approach to understanding the language and its instructions, should allow the user to perfectly understand the current state of the processor (\textit{what's happening}), and the effects (how that state changes) of each instruction (\textit{what happens next}). This is similar to some \gls{debugging} techniques used in some \glspl{high-level language}, which have been proven to improve programming skills\supercite{KLAHR1988362}.


% why foss/C++?
Lastly, we are firm believers in \gls{FOSS}, due to the fact that anyone can see the source code, modify it, learn from it, and contribute in order to improve it. We also consider important that the implementation is flexible enough to be easily \glsdisp{port}{ported} to many devices: \glspl{desktop device}, \glspl{embedded device}, \glspl{web application}, etc.


% conclussion
In this thesis, we present an open-source generic \gls{assembly} simulator focused on helping the user learn and understand \glspl{assembly} and the basics of \gls{computer} architecture. In particular, the simulator will be able to execute any \glsdisp{assembly}{assembly-like} language \gls{program} that can be defined through a simple basic \glsdisp{lisp}{LISP-like} language, in order for the user to perfectly understand what each instruction does.



\section{Objectives}\label{sec:objectives}
The main objective of this project is to design and develop a simulator that, unlike existing ones, enables the user to define and execute their own sets of \gls{assembly} instructions in a simple, generic, and easy to understand language, so the user can fully understand what each instruction does.

\noindent
The secondary objectives, derived from the main objective, are as follows:
\begin{itemize}
  \item \textbf{O1:} Simulate a simple and generic \gls{computer}: \gls{memory}, \glspl{register}, and a \gls{processor} that executes a simple and generic \gls{programming language}.
  \item \textbf{O2:} Define a simple and generic \gls{programming language} that allows to \glsdisp{programming}{program} the different components of the simulated \gls{computer}.
  \item \textbf{O3:} Allow the user to display in each \gls{clock cycle} the status of each component of the simulated
  \gls{computer}.
  \item \textbf{O4:} Allow the user to execute any program using their defined \gls{assembly}.
  \item \textbf{O5:} Create an implementation that allows the simulator to be used in many environments.
\end{itemize}


\section{Document Structure}\label{sec:structure}
The document contains the following chapters:
\begin{itemize}
  \item \chapterref{chap:introduction}, briefly presents the project, its motivations and objectives, and a description of the contents of the document.
  \item \chapterref{chap:state-of-the-art}, includes a description of the current stage of \gls{assembly} simulators, providing examples and comparing them with our proposal.
  \item \chapterref{chap:analysis}, explains the chosen solution, establishes its requirements, and presents the regulatory framework for project.
  \item \chapterref{chap:design}, details the system's design, including all of its components.
  \item \chapterref{chap:implementation}, includes the implementation details of the main parts of the developed software and the necessary steps for its deployment.
  \item \chapterref{chap:evaluation}, details the verification and validation of the system and its objectives, including test cases.
  \item \chapterref{chap:planning}, presents the concepts related to the followed planning, breaks down all project costs, and describes the socio-economic environment.
  \item \chapterref{chap:conclusions}, highlits the contributions of the project, explains our overall conclusions, and presents what future work could be done in order to improve it.
\end{itemize}